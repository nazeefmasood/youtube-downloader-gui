import { spawn, ChildProcess, execSync } from 'child_process'
import * as path from 'path'
import * as fs from 'fs'
import { EventEmitter } from 'events'
import { app } from 'electron'
import { logger } from './logger'
import { binaryManager } from './binaryManager'
import { fetchPotToken } from './potTokenServer'

interface ContentInfo {
  type: 'video' | 'playlist' | 'channel'
  id: string
  title: string
  thumbnail?: string
  duration?: number
  uploaderName?: string
  uploaderUrl?: string
  description?: string
  videoCount?: number
  entries?: Array<{
    id: string
    title: string
    duration?: number
    thumbnail?: string
    index: number
  }>
}

interface VideoFormat {
  formatId: string
  ext: string
  resolution: string
  quality: string
  filesize?: number
  fps?: number
  vcodec?: string
  acodec?: string
  isAudioOnly: boolean
}

interface DownloadProgress {
  percent: number
  speed?: string
  eta?: string
  downloaded?: string
  total?: string
  currentFile?: string
  currentIndex?: number
  totalFiles?: number
  status: 'downloading' | 'merging' | 'processing' | 'complete' | 'error' | 'waiting'
}

interface SubtitleInfo {
  lang: string
  langName: string
  isAutoGenerated: boolean
  ext: string
}

// Common language code to name mapping
const LANGUAGE_NAMES: Record<string, string> = {
  'en': 'English',
  'en-us': 'English (US)',
  'en-gb': 'English (UK)',
  'en-orig': 'English (Original)',
  'es': 'Spanish',
  'es-419': 'Spanish (Latin America)',
  'es-es': 'Spanish (Spain)',
  'fr': 'French',
  'fr-fr': 'French (France)',
  'de': 'German',
  'it': 'Italian',
  'pt': 'Portuguese',
  'pt-br': 'Portuguese (Brazil)',
  'pt-pt': 'Portuguese (Portugal)',
  'ru': 'Russian',
  'ja': 'Japanese',
  'ko': 'Korean',
  'zh': 'Chinese',
  'zh-cn': 'Chinese (Simplified)',
  'zh-tw': 'Chinese (Traditional)',
  'zh-hans': 'Chinese (Simplified)',
  'zh-hant': 'Chinese (Traditional)',
  'ar': 'Arabic',
  'hi': 'Hindi',
  'bn': 'Bengali',
  'tr': 'Turkish',
  'vi': 'Vietnamese',
  'th': 'Thai',
  'id': 'Indonesian',
  'ms': 'Malay',
  'nl': 'Dutch',
  'pl': 'Polish',
  'uk': 'Ukrainian',
  'sv': 'Swedish',
  'no': 'Norwegian',
  'da': 'Danish',
  'fi': 'Finnish',
  'cs': 'Czech',
  'el': 'Greek',
  'he': 'Hebrew',
  'hu': 'Hungarian',
  'ro': 'Romanian',
  'sk': 'Slovak',
  'bg': 'Bulgarian',
  'hr': 'Croatian',
  'sr': 'Serbian',
  'sl': 'Slovenian',
  'lt': 'Lithuanian',
  'lv': 'Latvian',
  'et': 'Estonian',
  'fa': 'Persian',
  'ur': 'Urdu',
  'ta': 'Tamil',
  'te': 'Telugu',
  'ml': 'Malayalam',
  'mr': 'Marathi',
  'gu': 'Gujarati',
  'kn': 'Kannada',
  'pa': 'Punjabi',
  'ab': 'Abkhazian',
  'af': 'Afrikaans',
  'am': 'Amharic',
  'hy': 'Armenian',
  'az': 'Azerbaijani',
  'bs': 'Bosnian',
  'ca': 'Catalan',
  'ce': 'Chechen',
  'co': 'Corsican',
  'eo': 'Esperanto',
  'eu': 'Basque',
  'fo': 'Faroese',
  'gl': 'Galician',
  'ka': 'Georgian',
  'ha': 'Hausa',
  'is': 'Icelandic',
  'ig': 'Igbo',
  'ga': 'Irish',
  'jv': 'Javanese',
  'kk': 'Kazakh',
  'km': 'Khmer',
  'rw': 'Kinyarwanda',
  'ku': 'Kurdish',
  'ky': 'Kyrgyz',
  'lo': 'Lao',
  'la': 'Latin',
  'lb': 'Luxembourgish',
  'mk': 'Macedonian',
  'mg': 'Malagasy',
  'mt': 'Maltese',
  'mi': 'Maori',
  'mn': 'Mongolian',
  'my': 'Myanmar (Burmese)',
  'ne': 'Nepali',
  'ny': 'Chichewa',
  'or': 'Odia (Oriya)',
  'ps': 'Pashto',
  'qu': 'Quechua',
  'rm': 'Romansh',
  'rn': 'Kirundi',
  'sm': 'Samoan',
  'sg': 'Sango',
  'sn': 'Shona',
  'sd': 'Sindhi',
  'si': 'Sinhala',
  'so': 'Somali',
  'st': 'Southern Sotho',
  'su': 'Sundanese',
  'sw': 'Swahili',
  'tg': 'Tajik',
  'tl': 'Filipino',
  'ti': 'Tigrinya',
  'ts': 'Tsonga',
  'tt': 'Tatar',
  'ug': 'Uyghur',
  'uz': 'Uzbek',
  'cy': 'Welsh',
  'fy': 'Western Frisian',
  'xh': 'Xhosa',
  'yi': 'Yiddish',
  'yo': 'Yoruba',
  'zu': 'Zulu',
}

interface SubtitleOptions {
  enabled: boolean
  languages: string[]
  includeAutoGenerated: boolean
  format: 'srt' | 'vtt' | 'ass'
  embedInVideo: boolean
}

interface DownloadOptions {
  url: string
  title?: string
  format: string
  audioOnly?: boolean
  outputPath: string
  organizeByType?: boolean
  delayBetweenDownloads?: number
  subtitleOptions?: SubtitleOptions
}

export class Downloader extends EventEmitter {
  private currentProcess: ChildProcess | null = null
  private detectionProcess: ChildProcess | null = null
  private ytdlpPath: string
  private ffmpegPath: string
  private cancelled = false
  private verified = false
  // Limit stderr to prevent memory issues during long downloads
  private readonly MAX_STDERR_LENGTH = 50 * 1024   // 50KB

  constructor() {
    super()
    this.ytdlpPath = this.getYtdlpPath()
    this.ffmpegPath = this.getFfmpegPath()
    this.verifyBinaries()
  }

  private verifyBinaries(): void {
    try {
      // Check yt-dlp
      logger.info('Verifying yt-dlp binary', this.ytdlpPath)
      if (fs.existsSync(this.ytdlpPath)) {
        const stats = fs.statSync(this.ytdlpPath)
        logger.info('yt-dlp binary found', `Size: ${stats.size} bytes, Mode: ${stats.mode.toString(8)}`)

        // Try to get version
        try {
          const version = execSync(`"${this.ytdlpPath}" --version`, { timeout: 10000 }).toString().trim()
          logger.info('yt-dlp version', version)
          this.verified = true
        } catch (versionErr) {
          logger.error('Failed to get yt-dlp version', versionErr instanceof Error ? versionErr : String(versionErr))
        }
      } else {
        logger.error('yt-dlp binary not found', this.ytdlpPath)
      }

      // Check ffmpeg using binaryManager
      const ffmpegStatus = binaryManager.checkFfmpeg()
      if (ffmpegStatus.available) {
        this.ffmpegPath = ffmpegStatus.path || 'ffmpeg'
        logger.info('ffmpeg verified', `Path: ${this.ffmpegPath}, Version: ${ffmpegStatus.version}`)
      } else {
        logger.error('ffmpeg not available', 'Video downloads may fail without ffmpeg')
      }

      // Check ffprobe
      const ffprobeStatus = binaryManager.checkFfprobe()
      if (ffprobeStatus.available) {
        logger.info('ffprobe verified', ffprobeStatus.path || 'system ffprobe')
      } else {
        logger.warn('ffprobe not available', 'Some features may be limited')
      }
    } catch (err) {
      logger.error('Binary verification failed', err instanceof Error ? err : String(err))
    }
  }

  isVerified(): boolean {
    return this.verified
  }

  private getYtdlpPath(): string {
    return binaryManager.getBinaryPath()
  }

  private getFfmpegPath(): string {
    // Use binaryManager to get ffmpeg path
    const ffmpegStatus = binaryManager.checkFfmpeg()
    if (ffmpegStatus.available && ffmpegStatus.path) {
      return ffmpegStatus.path
    }
    // Fallback to system ffmpeg (will fail if not installed)
    return 'ffmpeg'
  }

  // Check if ffmpeg is available for downloads
  isFfmpegAvailable(): boolean {
    const status = binaryManager.checkFfmpeg()
    return status.available
  }

  // Refresh ffmpeg path after download (call this after ffmpeg is downloaded)
  refreshFfmpegPath(): void {
    const ffmpegStatus = binaryManager.checkFfmpeg()
    if (ffmpegStatus.available && ffmpegStatus.path) {
      this.ffmpegPath = ffmpegStatus.path
      logger.info('ffmpeg path refreshed', `Path: ${this.ffmpegPath}, Version: ${ffmpegStatus.version}`)
    } else {
      logger.warn('ffmpeg refresh failed', 'ffmpeg still not available')
    }
  }

  // Get binary status for UI
  getBinaryStatus() {
    return binaryManager.getBinaryStatus()
  }

  private async getExtractorArgs(): Promise<string[]> {
    try {
      const result = await fetchPotToken()
      if (result) {
        logger.info('PO Token', `Using PO token (length: ${result.token.length})`)
        return [
          '--extractor-args',
          `youtube:po_token=web.gvs+${result.token};visitor_data=${result.visitorData}`,
        ]
      }
    } catch (err) {
      logger.warn('PO Token', `Failed to fetch, using fallback: ${err instanceof Error ? err.message : String(err)}`)
    }
    // Fallback: use web client without PO token
    return ['--extractor-args', 'youtube:player_client=web']
  }

  private runYtdlp(args: string[], isDetection = false): Promise<string> {
    return new Promise((resolve, reject) => {
      logger.info('Spawning yt-dlp', `Path: ${this.ytdlpPath}\nArgs: ${args.join(' ')}\nPATH: ${process.env.PATH}`)
      const ytdlp = spawn(this.ytdlpPath, args)

      // Track detection process for cancellation
      if (isDetection) {
        this.detectionProcess = ytdlp
      }

      let stdout = ''
      let stderr = ''

      ytdlp.stdout.on('data', (data) => {
        stdout += data.toString()
        // NOTE: Do NOT truncate stdout here - runYtdlp is used for JSON responses
        // (detectUrl, getFormats, getSubtitles) which require complete data
      })

      ytdlp.stderr.on('data', (data) => {
        const stderrChunk = data.toString()
        stderr += stderrChunk
        // Truncate stderr to prevent memory issues (stderr is only for error messages)
        if (stderr.length > this.MAX_STDERR_LENGTH) {
          stderr = stderr.slice(-this.MAX_STDERR_LENGTH)
        }
        // Log warnings and errors from yt-dlp
        if (stderrChunk.includes('WARNING') || stderrChunk.includes('ERROR')) {
          logger.info('yt-dlp stderr', stderrChunk.trim())
        }
      })

      ytdlp.on('close', (code) => {
        if (isDetection) {
          this.detectionProcess = null
        }
        if (code === 0) {
          // Log any warnings even on success
          if (stderr) {
            logger.info('yt-dlp completed with warnings', stderr.trim())
          }
          resolve(stdout)
        } else {
          reject(new Error(stderr || `yt-dlp exited with code ${code}`))
        }
      })

      ytdlp.on('error', (err) => {
        if (isDetection) {
          this.detectionProcess = null
        }
        logger.error('yt-dlp spawn error', `Args: ${args.join(' ')}\nError: ${err.message}`)
        reject(err)
      })
    })
  }

  cancelDetection(): void {
    if (this.detectionProcess) {
      this.detectionProcess.kill('SIGTERM')
      this.detectionProcess = null
    }
  }

  async detectUrl(url: string): Promise<ContentInfo> {
    const extractorArgs = await this.getExtractorArgs()
    const args = [
      '--dump-json',
      '--flat-playlist',
      '--no-warnings',
      ...extractorArgs,
      // Add rate limiting to avoid IP blocking
      '--sleep-requests', '1',
      '--extractor-retries', '3',
      '--socket-timeout', '30',
      url,
    ]

    const output = await this.runYtdlp(args, true)
    const lines = output.trim().split('\n').filter(Boolean)

    if (lines.length === 0) {
      throw new Error('No content found')
    }

    const firstEntry = JSON.parse(lines[0])

    if (firstEntry._type === 'playlist' || lines.length > 1 || firstEntry.playlist_count) {
      const isChannel = url.includes('/channel/') || url.includes('/@') || url.includes('/c/')

      // Show all playlist items (no 20-item limit)
      const entries = lines.map((line, index) => {
        try {
          const entry = JSON.parse(line)
          return {
            id: entry.id || entry.url,
            title: entry.title || `Video ${index + 1}`,
            duration: entry.duration,
            thumbnail: entry.thumbnail || entry.thumbnails?.[0]?.url,
            index: index + 1,
          }
        } catch {
          return null
        }
      }).filter(Boolean) as ContentInfo['entries']

      return {
        type: isChannel ? 'channel' : 'playlist',
        id: firstEntry.playlist_id || firstEntry.id || url,
        title: firstEntry.playlist_title || firstEntry.title || 'Unknown',
        thumbnail: firstEntry.playlist_thumbnail || firstEntry.thumbnail || firstEntry.thumbnails?.[0]?.url,
        uploaderName: firstEntry.uploader || firstEntry.channel,
        uploaderUrl: firstEntry.uploader_url || firstEntry.channel_url,
        description: firstEntry.description,
        videoCount: firstEntry.playlist_count || lines.length,
        entries,
      }
    }

    return {
      type: 'video',
      id: firstEntry.id,
      title: firstEntry.title,
      thumbnail: firstEntry.thumbnail || firstEntry.thumbnails?.[0]?.url,
      duration: firstEntry.duration,
      uploaderName: firstEntry.uploader || firstEntry.channel,
      uploaderUrl: firstEntry.uploader_url || firstEntry.channel_url,
      description: firstEntry.description,
    }
  }

  // Fallback formats when format detection fails
  private getDefaultFormats(): VideoFormat[] {
    return [
      { formatId: 'bestvideo+bestaudio/best', ext: 'mp4', resolution: 'best', quality: 'Best Quality', isAudioOnly: false },
      { formatId: 'bestvideo[height<=1080]+bestaudio/best', ext: 'mp4', resolution: '1080p', quality: '1080p', isAudioOnly: false },
      { formatId: 'bestvideo[height<=720]+bestaudio/best', ext: 'mp4', resolution: '720p', quality: '720p', isAudioOnly: false },
      { formatId: 'bestvideo[height<=480]+bestaudio/best', ext: 'mp4', resolution: '480p', quality: '480p', isAudioOnly: false },
      { formatId: 'bestvideo[height<=360]+bestaudio/best', ext: 'mp4', resolution: '360p', quality: '360p', isAudioOnly: false },
      { formatId: 'bestaudio/best', ext: 'mp3', resolution: 'audio', quality: 'MP3 (Best)', isAudioOnly: true },
      { formatId: 'bestaudio[ext=m4a]/bestaudio/best', ext: 'm4a', resolution: 'audio', quality: 'M4A (Best)', isAudioOnly: true },
    ]
  }

  async getFormats(url: string): Promise<VideoFormat[]> {
    const extractorArgs = await this.getExtractorArgs()
    const args = [
      '--dump-json',
      '--no-playlist',
      '--no-warnings',
      ...extractorArgs,
      // Add rate limiting to avoid IP blocking
      '--sleep-requests', '1',
      '--extractor-retries', '3',
      '--socket-timeout', '30',
      url,
    ]

    let output: string
    try {
      output = await this.runYtdlp(args)
    } catch (err) {
      // If format detection fails, return default formats
      logger.warn('Format detection failed, using defaults', err instanceof Error ? err.message : String(err))
      return this.getDefaultFormats()
    }

    // yt-dlp may output multiple JSON objects, take only the first one
    const firstLine = output.trim().split('\n')[0]

    let info
    try {
      info = JSON.parse(firstLine)
    } catch (parseErr) {
      logger.warn('Failed to parse format info, using defaults', parseErr instanceof Error ? parseErr.message : String(parseErr))
      return this.getDefaultFormats()
    }

    const formats: VideoFormat[] = []

    const allFormats = info.formats || []

    // Collect all video formats with their heights
    const videoFormats = allFormats.filter((f: Record<string, unknown>) =>
      f.vcodec && f.vcodec !== 'none' && typeof f.height === 'number' && (f.height as number) > 0
    )
    const audioFormats = allFormats.filter((f: Record<string, unknown>) =>
      f.acodec && f.acodec !== 'none' && (!f.vcodec || f.vcodec === 'none')
    )

    // Find the maximum available height
    const maxHeight = videoFormats.reduce((max: number, f: Record<string, unknown>) =>
      Math.max(max, f.height as number), 0
    )

    // Best audio format for size estimation (pick the last/best one)
    const bestAudioFormat = audioFormats.length > 0 ? audioFormats[audioFormats.length - 1] : null
    const bestAudioSize = (bestAudioFormat?.filesize as number) || 0

    // Best video format for "Best Quality" size estimation
    const bestVideoFormat = videoFormats.length > 0 ? videoFormats[videoFormats.length - 1] : null
    const bestTotalSize = ((bestVideoFormat?.filesize as number) || 0) + bestAudioSize

    logger.info('Format detection', `Max height: ${maxHeight}p, Video formats: ${videoFormats.length}, Audio formats: ${audioFormats.length}`)

    // Determine the best quality label based on max height
    const bestLabel = maxHeight >= 4320 ? '8K'
      : maxHeight >= 2160 ? '4K'
      : maxHeight >= 1440 ? '1440p'
      : maxHeight >= 1080 ? '1080p'
      : maxHeight >= 720 ? '720p'
      : maxHeight >= 480 ? '480p'
      : `${maxHeight}p`

    // Add "Best Quality" option first - this adapts to each video's max resolution
    // Important for playlists where videos have different max resolutions
    formats.push({
      formatId: 'bestvideo+bestaudio/best',
      ext: 'mp4',
      resolution: 'best',
      quality: `Best Quality (${bestLabel})`,
      filesize: bestTotalSize > 0 ? bestTotalSize : undefined,
      isAudioOnly: false,
    })

    // Always show all standard quality options up to the max available height
    // yt-dlp's format string handles fallback automatically
    // e.g. "bestvideo[height<=1080]" will pick the best format at or below 1080p
    const qualities: Array<{ height: number; label: string }> = [
      { height: 4320, label: '8K' },
      { height: 2160, label: '4K' },
      { height: 1440, label: '1440p' },
      { height: 1080, label: '1080p' },
      { height: 720, label: '720p' },
      { height: 480, label: '480p' },
      { height: 360, label: '360p' },
    ]

    for (const q of qualities) {
      // Show this quality option if the video has formats at or above this height
      if (maxHeight >= q.height) {
        // Find the closest video format for filesize estimation
        // Look for exact match first, then closest match at or below this height
        const exactMatch = videoFormats.find((f: Record<string, unknown>) => f.height === q.height)
        const closestMatch = exactMatch || videoFormats
          .filter((f: Record<string, unknown>) => (f.height as number) <= q.height)
          .pop()
        const estimatedVideoSize = (closestMatch?.filesize as number) || 0
        const estimatedSize = estimatedVideoSize + bestAudioSize

        formats.push({
          formatId: `bestvideo[height<=${q.height}]+bestaudio/best`,
          ext: 'mp4',
          resolution: `${q.height}p`,
          quality: q.label,
          filesize: estimatedSize > 0 ? estimatedSize : undefined,
          isAudioOnly: false,
        })
      }
    }

    // Add audio-only options
    const audioSize = (bestAudioFormat?.filesize as number) || undefined
    formats.push({
      formatId: 'bestaudio/best',
      ext: 'mp3',
      resolution: 'audio',
      quality: 'MP3 (Best)',
      filesize: audioSize,
      isAudioOnly: true,
    })

    const m4aFormat = allFormats.find((f: Record<string, unknown>) =>
      f.ext === 'm4a' && f.acodec && f.acodec !== 'none'
    )
    formats.push({
      formatId: 'bestaudio[ext=m4a]/bestaudio/best',
      ext: 'm4a',
      resolution: 'audio',
      quality: 'M4A (Best)',
      filesize: (m4aFormat?.filesize as number) || audioSize,
      isAudioOnly: true,
    })

    return formats
  }

  async getSubtitles(url: string): Promise<SubtitleInfo[]> {
    const extractorArgs = await this.getExtractorArgs()
    const args = [
      '--list-subs',
      '--skip-download',
      '--no-warnings',
      ...extractorArgs,
      // Add rate limiting to avoid 429 errors
      '--sleep-requests', '2',
      '--socket-timeout', '60',
      url,
    ]

    try {
      const output = await this.runYtdlp(args)
      const subtitles: SubtitleInfo[] = []

      // Parse the subtitle listing output
      // Format is like:
      // Available subtitles for VIDEO_ID:
      // Language  Name  Formats
      // en        English  vtt, ttml, srv3, srv2, srv1, json3
      // [info] Available automatic captions for VIDEO_ID:
      // Language  Name  Formats
      // en-orig   English (Original)  vtt, ttml, srv3, srv2, srv1, json3

      const lines = output.split('\n')
      let isAutoGenerated = false

      for (const line of lines) {
        if (line.includes('automatic captions')) {
          isAutoGenerated = true
          continue
        }
        if (line.includes('Available subtitles')) {
          isAutoGenerated = false
          continue
        }

        // Skip header lines and empty lines
        if (!line.trim() || line.startsWith('Language') || line.startsWith('[')) {
          continue
        }

        // Parse subtitle line: "en        English  vtt, ttml, srv3"
        const match = line.match(/^(\S+)\s+(.+?)\s+(vtt|srt|ttml|ass)/i)
        if (match) {
          const [, lang, langName, ext] = match
          const langCode = lang.trim().toLowerCase()

          // Try to get a better language name from our mapping
          let displayName = LANGUAGE_NAMES[langCode] || LANGUAGE_NAMES[langCode.split('-')[0]] || langName.trim()

          // If auto-generated, mark it
          if (isAutoGenerated && !displayName.includes('(Auto)')) {
            displayName += ' (Auto)'
          }

          subtitles.push({
            lang: lang.trim(),
            langName: displayName,
            isAutoGenerated,
            ext: ext.toLowerCase(),
          })
        }
      }

      logger.info('Subtitles found', `${subtitles.length} subtitle tracks`)

      // Sort subtitles: English first, then alphabetically by language name
      subtitles.sort((a, b) => {
        const aIsEn = a.lang.toLowerCase().startsWith('en')
        const bIsEn = b.lang.toLowerCase().startsWith('en')
        if (aIsEn && !bIsEn) return -1
        if (!aIsEn && bIsEn) return 1
        return a.langName.localeCompare(b.langName)
      })

      return subtitles
    } catch (err) {
      logger.warn('Failed to get subtitles', err instanceof Error ? err.message : String(err))
      return []
    }
  }

  async download(options: DownloadOptions): Promise<void> {
    const { url, title, format, audioOnly, outputPath, organizeByType, delayBetweenDownloads = 2000, subtitleOptions } = options
    this.cancelled = false

    // Use provided title instead of re-detecting (avoids 403 errors and unnecessary API calls)
    const videoTitle = title || 'Unknown'

    const outputDir = outputPath

    fs.mkdirSync(outputDir, { recursive: true })

    const extractorArgs = await this.getExtractorArgs()

    const args: string[] = [
      '--no-warnings',
      '--newline',
      '--progress',
      '--ignore-errors',  // Continue on errors (e.g., subtitle 429) instead of failing
      ...extractorArgs,
      // Retry options for handling 403/429 errors and network issues
      '--retries', '10',
      '--fragment-retries', '10',
      '--extractor-retries', '5',
      '--file-access-retries', '5',
      // Aggressive rate limiting to avoid 429 Too Many Requests
      '--sleep-requests', '2',
      '--sleep-interval', '2',         // Sleep 2s between downloads
      '--max-sleep-interval', '5',     // Up to 5s random sleep
      '--socket-timeout', '60',        // Increased timeout
      // Use native HLS downloader for better m3u8 handling
      '--hls-prefer-native',
      // FFmpeg location
      '--ffmpeg-location', this.ffmpegPath,
    ]

    // Output template - items are queued individually, so always single video template
    args.push('-o', path.join(outputDir, '%(title)s.%(ext)s'))
    args.push('--no-playlist')

    // Format selection - IMPORTANT: merge into single file with robust fallbacks
    if (format === 'subtitle-only') {
      // Subtitle-only download - skip the video
      args.push('--skip-download')
      logger.info('Subtitle-only download mode')
    } else if (audioOnly) {
      // Audio-only download with fallbacks
      args.push('-f', 'bestaudio/best')
      args.push('-x') // Extract audio
      const ext = format.includes('m4a') ? 'm4a' : 'mp3'
      args.push('--audio-format', ext)
      args.push('--audio-quality', '0') // Best quality
    } else {
      // Video format with audio merged - add robust fallbacks
      // Parse the format to add fallbacks if not already present
      let robustFormat = format

      // If format contains height constraint but no proper fallback, add them
      if (format.includes('height<=') && !format.includes('bestvideo+bestaudio/best')) {
        // Add fallback chain: original -> any video+audio -> combined best
        robustFormat = `${format}/bestvideo+bestaudio/best`
      } else if (format === 'bestvideo+bestaudio/best') {
        // Already has best fallback, add intermediate fallback
        robustFormat = 'bestvideo+bestaudio/bestvideo[ext=mp4]+bestaudio[ext=m4a]/best'
      }

      args.push('-f', robustFormat)
      args.push('--merge-output-format', 'mp4')

      logger.info('Using format selector', robustFormat)
    }

    // Subtitle options
    if (subtitleOptions?.enabled) {
      args.push('--write-subs')
      if (subtitleOptions.includeAutoGenerated) {
        args.push('--write-auto-subs')
      }

      // Always use specified languages (UI now ensures at least one is set)
      const langs = subtitleOptions.languages.length > 0
        ? subtitleOptions.languages.join(',')
        : 'en'  // Fallback to English
      args.push('--sub-langs', langs)

      args.push('--sub-format', subtitleOptions.format || 'srt')
      if (subtitleOptions.embedInVideo && !audioOnly) {
        args.push('--embed-subs')
      }
      // Add extra sleep for subtitle downloads to avoid 429 errors
      args.push('--sleep-subtitles', '2')
    }

    args.push(url)


    return new Promise((resolve, reject) => {
      this.currentProcess = spawn(this.ytdlpPath, args)

      let currentFile = videoTitle
      const currentIndex = 1
      const totalFiles = 1
      let stderrOutput = ''

      // Emit initial progress immediately so UI shows progress bar
      this.emit('progress', {
        percent: 0,
        currentFile,
        currentIndex,
        totalFiles,
        status: 'downloading',
      })

      this.currentProcess.stdout?.on('data', (data) => {
        if (this.cancelled) return

        const output = data.toString()
        const lines = output.split('\n')

        for (const line of lines) {
          // Parse progress: [download]  45.2% of 50.00MiB at 2.50MiB/s ETA 00:11
          const progressMatch = line.match(/\[download\]\s+(\d+\.?\d*)%\s+of\s+~?(\S+)\s+at\s+(\S+)\s+ETA\s+(\S+)/)
          if (progressMatch) {
            const progress: DownloadProgress = {
              percent: parseFloat(progressMatch[1]),
              total: progressMatch[2],
              speed: progressMatch[3],
              eta: progressMatch[4],
              currentFile,
              currentIndex,
              totalFiles,
              status: 'downloading',
            }
            this.emit('progress', progress)
          }

          // Merging status
          if (line.includes('[Merger]') || line.includes('[ffmpeg]')) {
            this.emit('progress', {
              percent: 99,
              currentFile,
              currentIndex,
              totalFiles,
              status: 'merging',
            })
          }

          // Destination file
          const destMatch = line.match(/\[download\]\s+Destination:\s+(.+)/)
          if (destMatch) {
            currentFile = path.basename(destMatch[1])
          }
        }
      })

      this.currentProcess.stderr?.on('data', (data) => {
        const output = data.toString()
        stderrOutput += output
        // Truncate to prevent memory issues during long downloads
        if (stderrOutput.length > this.MAX_STDERR_LENGTH) {
          stderrOutput = stderrOutput.slice(-this.MAX_STDERR_LENGTH)
        }

        // Log all stderr output for debugging
        logger.info('yt-dlp stderr', output.trim())

        // Detect specific error types for better user feedback
        if (output.includes('Sign in to confirm') || output.includes('bot')) {
          logger.warn('Bot detection warning', 'YouTube may be blocking the download')
        }

        if (output.includes('cookies') && output.includes('error')) {
          logger.warn('Cookie extraction failed', 'Continuing without cookies')
        }
      })


      this.currentProcess.on('close', (code) => {
        this.currentProcess = null
        if (this.cancelled) {
          this.emit('complete', { success: false, error: 'Download cancelled' })
          resolve()
        } else if (code === 0) {
          this.emit('progress', {
            percent: 100,
            currentFile,
            currentIndex: 1,
            totalFiles: 1,
            status: 'complete',
          })
          this.emit('complete', { success: true, filePath: outputDir })
          resolve()
        } else {
          // Extract meaningful error from stderr
          const stderrLines = stderrOutput.trim().split('\n').filter(l => l.trim())
          const errorLine = stderrLines.find(l =>
            l.includes('ERROR') || l.includes('HTTP Error') || l.includes('Forbidden') ||
            l.includes('Sign in') || l.includes('not available') || l.includes('Unable to')
          ) || stderrLines[stderrLines.length - 1] || ''
          const error = errorLine.replace(/^.*?ERROR:\s*/, '').trim() || `Download failed with code ${code}`
          logger.error('Download failed', `Code: ${code}\nStderr: ${stderrOutput.trim().slice(0, 500)}`)
          this.emit('complete', { success: false, error })
          reject(new Error(error))
        }
      })

      this.currentProcess.on('error', (err) => {
        this.currentProcess = null
        this.emit('complete', { success: false, error: err.message })
        reject(err)
      })
    })
  }

  cancel(): void {
    this.cancelled = true
    if (this.currentProcess) {
      this.currentProcess.kill('SIGTERM')
      this.currentProcess = null
    }
  }

  private sanitizeFilename(filename: string): string {
    return filename
      .replace(/[<>:"/\\|?*]/g, '')
      .replace(/\s+/g, ' ')
      .trim()
      .slice(0, 200)
  }
}
