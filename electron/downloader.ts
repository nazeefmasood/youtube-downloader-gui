import { spawn, ChildProcess, execSync } from 'child_process'
import * as path from 'path'
import * as fs from 'fs'
import { EventEmitter } from 'events'
import { app } from 'electron'
import { logger } from './logger'
import { binaryManager } from './binaryManager'

interface ContentInfo {
  type: 'video' | 'playlist' | 'channel'
  id: string
  title: string
  thumbnail?: string
  duration?: number
  uploaderName?: string
  uploaderUrl?: string
  description?: string
  videoCount?: number
  entries?: Array<{
    id: string
    title: string
    duration?: number
    thumbnail?: string
    index: number
  }>
}

interface VideoFormat {
  formatId: string
  ext: string
  resolution: string
  quality: string
  filesize?: number
  fps?: number
  vcodec?: string
  acodec?: string
  isAudioOnly: boolean
}

interface DownloadProgress {
  percent: number
  speed?: string
  eta?: string
  downloaded?: string
  total?: string
  currentFile?: string
  currentIndex?: number
  totalFiles?: number
  status: 'downloading' | 'merging' | 'processing' | 'complete' | 'error' | 'waiting'
}

interface SubtitleInfo {
  lang: string
  langName: string
  isAutoGenerated: boolean
  ext: string
}

interface SubtitleOptions {
  enabled: boolean
  languages: string[]
  includeAutoGenerated: boolean
  format: 'srt' | 'vtt' | 'ass'
  embedInVideo: boolean
}

interface DownloadOptions {
  url: string
  format: string
  audioOnly?: boolean
  outputPath: string
  organizeByType?: boolean
  delayBetweenDownloads?: number
  subtitleOptions?: SubtitleOptions
}

export class Downloader extends EventEmitter {
  private currentProcess: ChildProcess | null = null
  private detectionProcess: ChildProcess | null = null
  private ytdlpPath: string
  private ffmpegPath: string
  private cancelled = false
  private verified = false

  constructor() {
    super()
    this.ytdlpPath = this.getYtdlpPath()
    this.ffmpegPath = this.getFfmpegPath()
    this.verifyBinaries()
  }

  private verifyBinaries(): void {
    try {
      // Check yt-dlp
      logger.info('Verifying yt-dlp binary', this.ytdlpPath)
      if (fs.existsSync(this.ytdlpPath)) {
        const stats = fs.statSync(this.ytdlpPath)
        logger.info('yt-dlp binary found', `Size: ${stats.size} bytes, Mode: ${stats.mode.toString(8)}`)

        // Try to get version
        try {
          const version = execSync(`"${this.ytdlpPath}" --version`, { timeout: 10000 }).toString().trim()
          logger.info('yt-dlp version', version)
          this.verified = true
        } catch (versionErr) {
          logger.error('Failed to get yt-dlp version', versionErr instanceof Error ? versionErr : String(versionErr))
        }
      } else {
        logger.error('yt-dlp binary not found', this.ytdlpPath)
      }

      // Check ffmpeg
      logger.info('Verifying ffmpeg binary', this.ffmpegPath)
      if (this.ffmpegPath && this.ffmpegPath !== 'ffmpeg') {
        if (fs.existsSync(this.ffmpegPath)) {
          logger.info('ffmpeg binary found', this.ffmpegPath)
        } else {
          logger.warn('ffmpeg binary not found at path', this.ffmpegPath)
        }
      } else {
        logger.info('Using system ffmpeg')
      }
    } catch (err) {
      logger.error('Binary verification failed', err instanceof Error ? err : String(err))
    }
  }

  isVerified(): boolean {
    return this.verified
  }

  private getYtdlpPath(): string {
    return binaryManager.getBinaryPath()
  }

  private getFfmpegPath(): string {
    // Use ffmpeg-static which provides the path to bundled ffmpeg
    try {
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      const ffmpegStatic = require('ffmpeg-static')
      return ffmpegStatic
    } catch {
      // Fallback to system ffmpeg
      return 'ffmpeg'
    }
  }

  private runYtdlp(args: string[], isDetection = false): Promise<string> {
    return new Promise((resolve, reject) => {
      logger.info('Spawning yt-dlp', `Path: ${this.ytdlpPath}\nArgs: ${args.join(' ')}\nPATH: ${process.env.PATH}`)
      const ytdlp = spawn(this.ytdlpPath, args)

      // Track detection process for cancellation
      if (isDetection) {
        this.detectionProcess = ytdlp
      }

      let stdout = ''
      let stderr = ''

      ytdlp.stdout.on('data', (data) => {
        stdout += data.toString()
      })

      ytdlp.stderr.on('data', (data) => {
        const stderrChunk = data.toString()
        stderr += stderrChunk
        // Log warnings and errors from yt-dlp
        if (stderrChunk.includes('WARNING') || stderrChunk.includes('ERROR')) {
          logger.info('yt-dlp stderr', stderrChunk.trim())
        }
      })

      ytdlp.on('close', (code) => {
        if (isDetection) {
          this.detectionProcess = null
        }
        if (code === 0) {
          // Log any warnings even on success
          if (stderr) {
            logger.info('yt-dlp completed with warnings', stderr.trim())
          }
          resolve(stdout)
        } else {
          reject(new Error(stderr || `yt-dlp exited with code ${code}`))
        }
      })

      ytdlp.on('error', (err) => {
        if (isDetection) {
          this.detectionProcess = null
        }
        logger.error('yt-dlp spawn error', `Args: ${args.join(' ')}\nError: ${err.message}`)
        reject(err)
      })
    })
  }

  cancelDetection(): void {
    if (this.detectionProcess) {
      this.detectionProcess.kill('SIGTERM')
      this.detectionProcess = null
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  async detectUrl(url: string): Promise<ContentInfo> {
    const args = [
      '--dump-json',
      '--flat-playlist',
      '--no-warnings',
      // Use multi-client approach to avoid bot detection
      '--extractor-args', 'youtube:player_client=default,web_creator,mweb,android',
      // Add rate limiting to avoid IP blocking
      '--sleep-requests', '1',
      '--extractor-retries', '3',
      '--socket-timeout', '30',
      url,
    ]

    const output = await this.runYtdlp(args, true)
    const lines = output.trim().split('\n').filter(Boolean)

    if (lines.length === 0) {
      throw new Error('No content found')
    }

    const firstEntry = JSON.parse(lines[0])

    if (firstEntry._type === 'playlist' || lines.length > 1 || firstEntry.playlist_count) {
      const isChannel = url.includes('/channel/') || url.includes('/@') || url.includes('/c/')

      // Show all playlist items (no 20-item limit)
      const entries = lines.map((line, index) => {
        try {
          const entry = JSON.parse(line)
          return {
            id: entry.id || entry.url,
            title: entry.title || `Video ${index + 1}`,
            duration: entry.duration,
            thumbnail: entry.thumbnail || entry.thumbnails?.[0]?.url,
            index: index + 1,
          }
        } catch {
          return null
        }
      }).filter(Boolean) as ContentInfo['entries']

      return {
        type: isChannel ? 'channel' : 'playlist',
        id: firstEntry.playlist_id || firstEntry.id || url,
        title: firstEntry.playlist_title || firstEntry.title || 'Unknown',
        thumbnail: firstEntry.playlist_thumbnail || firstEntry.thumbnail || firstEntry.thumbnails?.[0]?.url,
        uploaderName: firstEntry.uploader || firstEntry.channel,
        uploaderUrl: firstEntry.uploader_url || firstEntry.channel_url,
        description: firstEntry.description,
        videoCount: firstEntry.playlist_count || lines.length,
        entries,
      }
    }

    return {
      type: 'video',
      id: firstEntry.id,
      title: firstEntry.title,
      thumbnail: firstEntry.thumbnail || firstEntry.thumbnails?.[0]?.url,
      duration: firstEntry.duration,
      uploaderName: firstEntry.uploader || firstEntry.channel,
      uploaderUrl: firstEntry.uploader_url || firstEntry.channel_url,
      description: firstEntry.description,
    }
  }

  // Fallback formats when format detection fails
  private getDefaultFormats(): VideoFormat[] {
    return [
      { formatId: 'bestvideo+bestaudio/best', ext: 'mp4', resolution: 'best', quality: 'Best Quality', isAudioOnly: false },
      { formatId: 'bestvideo[height<=1080]+bestaudio/best[height<=1080]', ext: 'mp4', resolution: '1080p', quality: '1080p', isAudioOnly: false },
      { formatId: 'bestvideo[height<=720]+bestaudio/best[height<=720]', ext: 'mp4', resolution: '720p', quality: '720p', isAudioOnly: false },
      { formatId: 'bestvideo[height<=480]+bestaudio/best[height<=480]', ext: 'mp4', resolution: '480p', quality: '480p', isAudioOnly: false },
      { formatId: 'bestvideo[height<=360]+bestaudio/best[height<=360]', ext: 'mp4', resolution: '360p', quality: '360p', isAudioOnly: false },
      { formatId: 'bestaudio/best', ext: 'mp3', resolution: 'audio', quality: 'MP3 (Best)', isAudioOnly: true },
      { formatId: 'bestaudio[ext=m4a]/bestaudio/best', ext: 'm4a', resolution: 'audio', quality: 'M4A (Best)', isAudioOnly: true },
    ]
  }

  async getFormats(url: string): Promise<VideoFormat[]> {
    const args = [
      '--dump-json',
      '--no-playlist',
      '--no-warnings',
      // Use multi-client approach to avoid bot detection
      '--extractor-args', 'youtube:player_client=default,web_creator,mweb,android',
      // Add rate limiting to avoid IP blocking
      '--sleep-requests', '1',
      '--extractor-retries', '3',
      '--socket-timeout', '30',
      url,
    ]

    let output: string
    try {
      output = await this.runYtdlp(args)
    } catch (err) {
      // If format detection fails, return default formats
      logger.warn('Format detection failed, using defaults', err instanceof Error ? err.message : String(err))
      return this.getDefaultFormats()
    }

    // yt-dlp may output multiple JSON objects, take only the first one
    const firstLine = output.trim().split('\n')[0]

    let info
    try {
      info = JSON.parse(firstLine)
    } catch (parseErr) {
      logger.warn('Failed to parse format info, using defaults', parseErr instanceof Error ? parseErr.message : String(parseErr))
      return this.getDefaultFormats()
    }

    const formats: VideoFormat[] = []
    const seenQualities = new Set<string>()

    const allFormats = info.formats || []

    // Add "Best Quality" option first - downloads highest available quality
    formats.push({
      formatId: 'bestvideo+bestaudio/best',
      ext: 'mp4',
      resolution: 'best',
      quality: 'Best Quality',
      isAudioOnly: false,
    })

    // Add combined format options (these are what most users want)
    // Include 8K (4320p) and other high resolutions
    const qualities = ['4320', '2160', '1440', '1080', '720', '480', '360']
    for (const q of qualities) {
      const hasQuality = allFormats.some((f: Record<string, unknown>) =>
        f.height === parseInt(q) && f.vcodec && f.vcodec !== 'none'
      )
      if (hasQuality) {
        const label = q === '4320' ? '8K' : q === '2160' ? '4K' : `${q}p`
        formats.push({
          formatId: `bestvideo[height<=${q}]+bestaudio/best[height<=${q}]`,
          ext: 'mp4',
          resolution: `${q}p`,
          quality: label,
          isAudioOnly: false,
        })
        seenQualities.add(q)
      }
    }

    // Add audio-only options
    formats.push({
      formatId: 'bestaudio/best',
      ext: 'mp3',
      resolution: 'audio',
      quality: 'MP3 (Best)',
      isAudioOnly: true,
    })

    formats.push({
      formatId: 'bestaudio[ext=m4a]/bestaudio/best',
      ext: 'm4a',
      resolution: 'audio',
      quality: 'M4A (Best)',
      isAudioOnly: true,
    })

    return formats
  }

  private getQualityLabel(height: number): string {
    if (height >= 2160) return '2160p'
    if (height >= 1440) return '1440p'
    if (height >= 1080) return '1080p'
    if (height >= 720) return '720p'
    if (height >= 480) return '480p'
    if (height >= 360) return '360p'
    return `${height}p`
  }

  async getSubtitles(url: string): Promise<SubtitleInfo[]> {
    const args = [
      '--list-subs',
      '--skip-download',
      '--no-warnings',
      '--extractor-args', 'youtube:player_client=default,web_creator,mweb,android',
      url,
    ]

    try {
      const output = await this.runYtdlp(args)
      const subtitles: SubtitleInfo[] = []

      // Parse the subtitle listing output
      // Format is like:
      // Available subtitles for VIDEO_ID:
      // Language  Name  Formats
      // en        English  vtt, ttml, srv3, srv2, srv1, json3
      // [info] Available automatic captions for VIDEO_ID:
      // Language  Name  Formats
      // en-orig   English (Original)  vtt, ttml, srv3, srv2, srv1, json3

      const lines = output.split('\n')
      let isAutoGenerated = false

      for (const line of lines) {
        if (line.includes('automatic captions')) {
          isAutoGenerated = true
          continue
        }
        if (line.includes('Available subtitles')) {
          isAutoGenerated = false
          continue
        }

        // Skip header lines and empty lines
        if (!line.trim() || line.startsWith('Language') || line.startsWith('[')) {
          continue
        }

        // Parse subtitle line: "en        English  vtt, ttml, srv3"
        const match = line.match(/^(\S+)\s+(.+?)\s+(vtt|srt|ttml|ass)/i)
        if (match) {
          const [, lang, langName, ext] = match
          subtitles.push({
            lang: lang.trim(),
            langName: langName.trim(),
            isAutoGenerated,
            ext: ext.toLowerCase(),
          })
        }
      }

      logger.info('Subtitles found', `${subtitles.length} subtitle tracks`)
      return subtitles
    } catch (err) {
      logger.warn('Failed to get subtitles', err instanceof Error ? err.message : String(err))
      return []
    }
  }

  async download(options: DownloadOptions): Promise<void> {
    const { url, format, audioOnly, outputPath, organizeByType, delayBetweenDownloads = 2000, subtitleOptions } = options
    this.cancelled = false

    const contentInfo = await this.detectUrl(url)

    let outputDir = outputPath
    if (organizeByType) {
      if (contentInfo.type === 'playlist') {
        outputDir = path.join(outputPath, 'Playlists', this.sanitizeFilename(contentInfo.title))
      } else if (contentInfo.type === 'channel') {
        outputDir = path.join(outputPath, 'Channels', this.sanitizeFilename(contentInfo.title))
      }
    }

    fs.mkdirSync(outputDir, { recursive: true })

    const args: string[] = [
      '--no-warnings',
      '--newline',
      '--progress',
      // Use multi-client approach to avoid bot detection
      '--extractor-args', 'youtube:player_client=default,web_creator,mweb,android',
      // Add rate limiting to avoid IP blocking
      '--sleep-requests', '1',
      '--extractor-retries', '3',
      '--socket-timeout', '30',
      '--ffmpeg-location', this.ffmpegPath,
    ]

    // Try to extract cookies from browser to bypass bot detection and age restrictions
    // This significantly improves success rate for YouTube downloads
    // yt-dlp will try Chrome first, then other browsers automatically
    args.push('--cookies-from-browser', 'chrome')
    logger.info('Attempting to use cookies from Chrome browser')

    // Prefer HTTPS protocol over m3u8 streams to avoid ffmpeg issues
    // This fixes "downloaded file is empty" errors with certain formats
    if (!audioOnly) {
      args.push('-S', 'proto:https')
    }

    // Output template
    if (contentInfo.type === 'playlist') {
      args.push('-o', path.join(outputDir, '%(playlist_index)02d - %(title)s.%(ext)s'))
      // Add delay between downloads for playlists
      args.push('--sleep-interval', String(Math.floor(delayBetweenDownloads / 1000)))
      args.push('--max-sleep-interval', String(Math.floor(delayBetweenDownloads / 1000) + 2))
    } else {
      args.push('-o', path.join(outputDir, '%(title)s.%(ext)s'))
    }

    // Format selection - IMPORTANT: merge into single file
    if (audioOnly) {
      // Audio-only download
      args.push('-f', 'bestaudio/best')
      args.push('-x') // Extract audio
      const ext = format.includes('m4a') ? 'm4a' : 'mp3'
      args.push('--audio-format', ext)
      args.push('--audio-quality', '0') // Best quality
    } else {
      // Video format with audio merged
      args.push('-f', format)
      args.push('--merge-output-format', 'mp4')
    }

    // Subtitle options
    if (subtitleOptions?.enabled) {
      args.push('--write-subs')
      if (subtitleOptions.includeAutoGenerated) {
        args.push('--write-auto-subs')
      }
      if (subtitleOptions.languages.length > 0) {
        args.push('--sub-langs', subtitleOptions.languages.join(','))
      } else {
        args.push('--sub-langs', 'en')  // Default to English
      }
      args.push('--sub-format', subtitleOptions.format || 'srt')
      if (subtitleOptions.embedInVideo && !audioOnly) {
        args.push('--embed-subs')
      }
    }

    args.push(url)


    return new Promise((resolve, reject) => {
      this.currentProcess = spawn(this.ytdlpPath, args)

      let currentFile = ''
      let currentIndex = 0
      const totalFiles = contentInfo.videoCount || 1

      this.currentProcess.stdout?.on('data', (data) => {
        if (this.cancelled) return

        const output = data.toString()
        const lines = output.split('\n')

        for (const line of lines) {
          // Parse progress: [download]  45.2% of 50.00MiB at 2.50MiB/s ETA 00:11
          const progressMatch = line.match(/\[download\]\s+(\d+\.?\d*)%\s+of\s+~?(\S+)\s+at\s+(\S+)\s+ETA\s+(\S+)/)
          if (progressMatch) {
            const progress: DownloadProgress = {
              percent: parseFloat(progressMatch[1]),
              total: progressMatch[2],
              speed: progressMatch[3],
              eta: progressMatch[4],
              currentFile,
              currentIndex,
              totalFiles,
              status: 'downloading',
            }
            this.emit('progress', progress)
          }

          // Merging status
          if (line.includes('[Merger]') || line.includes('[ffmpeg]')) {
            this.emit('progress', {
              percent: 99,
              currentFile,
              currentIndex,
              totalFiles,
              status: 'merging',
            })
          }

          // Destination file
          const destMatch = line.match(/\[download\]\s+Destination:\s+(.+)/)
          if (destMatch) {
            currentFile = path.basename(destMatch[1])
          }

          // Downloading item X of Y
          const itemMatch = line.match(/\[download\]\s+Downloading\s+(?:video|item)\s+(\d+)\s+of\s+(\d+)/)
          if (itemMatch) {
            const newIndex = parseInt(itemMatch[1])
            // Emit videoComplete for previous video when starting a new one
            if (newIndex > currentIndex && currentFile) {
              this.emit('videoComplete', {
                index: currentIndex,
                totalFiles,
                title: currentFile.replace(/\.[^/.]+$/, ''), // Remove extension
                filePath: path.join(outputDir, currentFile),
              })
            }
            currentIndex = newIndex
            // Emit waiting status before starting next download
            if (currentIndex > 1) {
              this.emit('progress', {
                percent: 0,
                currentFile: '',
                currentIndex,
                totalFiles,
                status: 'waiting',
              })
            }
          }

          // Already downloaded - also emit videoComplete
          if (line.includes('has already been downloaded')) {
            const alreadyMatch = line.match(/\[download\]\s+(.+)\s+has already been downloaded/)
            if (alreadyMatch) {
              this.emit('videoComplete', {
                index: currentIndex,
                totalFiles,
                title: path.basename(alreadyMatch[1]).replace(/\.[^/.]+$/, ''),
                filePath: alreadyMatch[1],
                alreadyDownloaded: true,
              })
            }
            currentIndex++
          }
        }
      })

      this.currentProcess.stderr?.on('data', (data) => {
        const output = data.toString()

        // Log all stderr output for debugging
        logger.info('yt-dlp stderr', output.trim())

        // Detect specific error types for better user feedback
        if (output.includes('downloaded file is empty')) {
          logger.error('Empty file error detected', 'This may be due to bot detection or format issues. Trying with cookies and protocol preferences.')
        }

        if (output.includes('Sign in to confirm') || output.includes('bot')) {
          logger.warn('Bot detection warning', 'YouTube may be blocking the download. Using browser cookies may help.')
        }

        // Check for cookie errors and continue without cookies
        if (output.includes('cookies') && output.includes('error')) {
          logger.warn('Cookie extraction failed', 'Continuing without cookies')
        }
      })


      this.currentProcess.on('close', (code) => {
        this.currentProcess = null
        if (this.cancelled) {
          this.emit('complete', { success: false, error: 'Download cancelled' })
          resolve()
        } else if (code === 0) {
          // Emit videoComplete for the last video (for playlists/channels)
          if (currentFile && totalFiles > 1) {
            this.emit('videoComplete', {
              index: currentIndex || totalFiles,
              totalFiles,
              title: currentFile.replace(/\.[^/.]+$/, ''),
              filePath: path.join(outputDir, currentFile),
            })
          }
          this.emit('progress', {
            percent: 100,
            currentFile,
            currentIndex: totalFiles,
            totalFiles,
            status: 'complete',
          })
          this.emit('complete', { success: true, filePath: outputDir })
          resolve()
        } else {
          const error = `Download failed with code ${code}`
          this.emit('complete', { success: false, error })
          reject(new Error(error))
        }
      })

      this.currentProcess.on('error', (err) => {
        this.currentProcess = null
        this.emit('complete', { success: false, error: err.message })
        reject(err)
      })
    })
  }

  cancel(): void {
    this.cancelled = true
    if (this.currentProcess) {
      this.currentProcess.kill('SIGTERM')
      this.currentProcess = null
    }
  }

  private sanitizeFilename(filename: string): string {
    return filename
      .replace(/[<>:"/\\|?*]/g, '')
      .replace(/\s+/g, ' ')
      .trim()
      .slice(0, 200)
  }
}
