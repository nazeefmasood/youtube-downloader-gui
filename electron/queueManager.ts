import { EventEmitter } from 'events'
import { Downloader } from './downloader'
import { app } from 'electron'
import * as path from 'path'
import * as fs from 'fs'
import { logger } from './logger'

export interface SubtitleOptions {
  enabled: boolean
  languages: string[]
  includeAutoGenerated: boolean
  format: 'srt' | 'vtt' | 'ass'
  embedInVideo: boolean
}

export interface QueueItem {
  id: string
  url: string
  title: string
  thumbnail?: string
  format: string
  qualityLabel?: string
  audioOnly: boolean
  status: 'pending' | 'downloading' | 'completed' | 'failed' | 'cancelled' | 'paused'
  progress?: DownloadProgress
  addedAt: number
  source: 'app' | 'extension'
  sourceType?: 'single' | 'playlist' | 'channel'
  contentType?: 'video' | 'audio' | 'subtitle' | 'video+sub'
  subtitleOptions?: SubtitleOptions
  subtitleDisplayNames?: string
  batchGroupId?: string
  error?: string
}

export interface BatchStatus {
  active: boolean
  groupId: string | null
  batchNumber: number
  totalBatches: number
  itemsInCurrentBatch: number
  batchSize: number
  totalItems: number
  completedItems: number
  isPaused: boolean
  pauseRemaining: number
  pauseDuration: number
}

export interface CountdownInfo {
  type: 'batch-pause' | 'download-delay' | 'none'
  remaining: number
  total: number
  label: string
}

export interface DownloadProgress {
  percent: number
  speed?: string
  eta?: string
  downloaded?: string
  total?: string
  currentFile?: string
  currentIndex?: number
  totalFiles?: number
  status: 'downloading' | 'merging' | 'processing' | 'complete' | 'error' | 'waiting'
}

export interface QueueStatus {
  items: QueueItem[]
  isProcessing: boolean
  isPaused: boolean
  currentItemId: string | null
  batchStatus: BatchStatus | null
  countdownInfo: CountdownInfo | null
}

export class QueueManager extends EventEmitter {
  private items: QueueItem[] = []
  private isProcessing = false
  private isPaused = false
  private currentItemId: string | null = null
  private downloader: Downloader
  private downloadPath: string
  private settings: { organizeByType?: boolean; delayBetweenDownloads?: number } = {}
  private queueFilePath: string
  private saveTimeout: NodeJS.Timeout | null = null
  private readonly SAVE_DEBOUNCE_MS = 1000

  // Batch download state
  private batchGroups: Map<string, { totalItems: number; completedItems: number; sourceType: string }> = new Map()
  private batchPauseTimer: NodeJS.Timeout | null = null
  private batchPauseEndTime: number = 0
  private countdownInterval: NodeJS.Timeout | null = null
  private delayTimer: NodeJS.Timeout | null = null
  private countdownInfo: CountdownInfo | null = null
  private batchSettings = {
    batchSize: 25,
    batchPauseShort: 5, // minutes, for <=50 items
    batchPauseLong: 10, // minutes, for >50 items
    batchDownloadEnabled: true,
  }

  constructor() {
    super()
    this.downloader = new Downloader()
    this.downloadPath = this.getDefaultDownloadPath()
    this.queueFilePath = path.join(app.getPath('userData'), 'queue.json')
    this.loadQueue()
    this.setupDownloaderListeners()
  }

  private loadQueue(): void {
    try {
      if (fs.existsSync(this.queueFilePath)) {
        const data = JSON.parse(fs.readFileSync(this.queueFilePath, 'utf-8'))
        this.items = (data.items || []).map((item: QueueItem) => ({
          ...item,
          // Reset downloading items to paused on restart (they were interrupted)
          status: item.status === 'downloading' ? 'paused' : item.status,
          // Clear progress for interrupted downloads
          progress: item.status === 'downloading' ? undefined : item.progress,
        }))
        this.isPaused = data.isPaused || false
        logger.info('Queue loaded', `${this.items.length} items, paused: ${this.isPaused}`)
      }
    } catch (err) {
      logger.error('Failed to load queue', err instanceof Error ? err : String(err))
      this.items = []
      this.isPaused = false
    }
  }

  private saveQueue(): void {
    try {
      const data = {
        items: this.items,
        isPaused: this.isPaused,
      }
      fs.writeFileSync(this.queueFilePath, JSON.stringify(data, null, 2), 'utf-8')
    } catch (err) {
      logger.error('Failed to save queue', err instanceof Error ? err : String(err))
    }
  }

  private debouncedSaveQueue(): void {
    if (this.saveTimeout) clearTimeout(this.saveTimeout)
    this.saveTimeout = setTimeout(() => {
      this.saveQueue()
      this.saveTimeout = null
    }, this.SAVE_DEBOUNCE_MS)
  }

  private getDefaultDownloadPath(): string {
    const home = app.getPath('home')
    return path.join(home, 'Downloads', 'Youtube Downloads')
  }

  setDownloadPath(downloadPath: string): void {
    this.downloadPath = downloadPath
  }

  setSettings(settings: {
    organizeByType?: boolean
    delayBetweenDownloads?: number
    batchSize?: number
    batchPauseShort?: number
    batchPauseLong?: number
    batchDownloadEnabled?: boolean
  }): void {
    this.settings = settings
    if (settings.batchSize !== undefined) this.batchSettings.batchSize = settings.batchSize
    if (settings.batchPauseShort !== undefined) this.batchSettings.batchPauseShort = settings.batchPauseShort
    if (settings.batchPauseLong !== undefined) this.batchSettings.batchPauseLong = settings.batchPauseLong
    if (settings.batchDownloadEnabled !== undefined) this.batchSettings.batchDownloadEnabled = settings.batchDownloadEnabled
  }

  private setupDownloaderListeners(): void {
    this.downloader.on('progress', (progress: DownloadProgress) => {
      if (this.currentItemId) {
        const item = this.items.find(i => i.id === this.currentItemId)
        if (item) {
          item.progress = progress
          item.status = 'downloading'
          this.emitUpdate()
        }
      }
    })

    this.downloader.on('complete', (result: { success: boolean; filePath?: string; error?: string }) => {
      if (this.currentItemId) {
        const item = this.items.find(i => i.id === this.currentItemId)
        if (item) {
          if (result.success) {
            item.status = 'completed'
            logger.info('Download completed', item.title)

            // Track batch completion
            if (item.batchGroupId) {
              const group = this.batchGroups.get(item.batchGroupId)
              if (group) {
                group.completedItems++
              }
            }

            // Emit item complete event for history
            this.emit('itemComplete', {
              id: item.id,
              title: item.title,
              url: item.url,
              thumbnail: item.thumbnail,
              filePath: result.filePath,
              audioOnly: item.audioOnly,
            })
          } else {
            item.status = 'failed'
            item.error = result.error
            logger.error('Download failed', `${item.title}: ${result.error}`)
          }
        }

        const completedItem = item
        this.currentItemId = null
        this.isProcessing = false
        // Emit update AFTER clearing isProcessing so UI shows correct state
        this.emitUpdate()

        // Check if we need a batch pause
        if (completedItem?.batchGroupId && this.batchSettings.batchDownloadEnabled && result.success) {
          const group = this.batchGroups.get(completedItem.batchGroupId)
          if (group && group.completedItems > 0 && group.completedItems % this.batchSettings.batchSize === 0) {
            // Batch boundary reached - start batch pause
            const hasPending = this.items.some(i =>
              i.batchGroupId === completedItem.batchGroupId && i.status === 'pending'
            )
            if (hasPending) {
              this.startBatchPause(completedItem.batchGroupId)
              return
            }
          }
        }

        // Normal delay between downloads
        const delay = this.settings.delayBetweenDownloads ?? 3000
        this.clearDelayTimer()
        this.startDownloadDelay(delay)
        this.delayTimer = setTimeout(() => {
          this.clearCountdownInterval()
          this.countdownInfo = null
          this.emitUpdate()
          if (!this.isPaused) {
            this.processNext()
          }
        }, delay)
      }
    })

    this.downloader.on('error', (error: string) => {
      if (this.currentItemId) {
        const item = this.items.find(i => i.id === this.currentItemId)
        if (item) {
          item.status = 'failed'
          item.error = error
          this.emitUpdate()
        }
        this.currentItemId = null
        this.isProcessing = false

        // Process next item
        setTimeout(() => {
          if (!this.isPaused) {
            this.processNext()
          }
        }, 1000)
      }
    })
  }

  private emitUpdate(): void {
    this.debouncedSaveQueue()  // Persist with debounce to reduce disk I/O
    this.emit('update', this.getStatus())
  }

  getStatus(): QueueStatus {
    return {
      items: [...this.items],
      isProcessing: this.isProcessing,
      isPaused: this.isPaused,
      currentItemId: this.currentItemId,
      batchStatus: this.getBatchStatus(),
      countdownInfo: this.countdownInfo,
    }
  }

  private getBatchStatus(): BatchStatus | null {
    // Find the active batch group (the one being currently processed)
    const currentItem = this.currentItemId ? this.items.find(i => i.id === this.currentItemId) : null
    const groupId = currentItem?.batchGroupId || this.getLastActiveBatchGroupId()

    if (!groupId) return null

    const group = this.batchGroups.get(groupId)
    if (!group) return null

    const batchSize = this.batchSettings.batchSize
    const batchNumber = Math.floor(group.completedItems / batchSize) + 1
    const totalBatches = Math.ceil(group.totalItems / batchSize)
    const itemsInCurrentBatch = group.completedItems % batchSize

    return {
      active: true,
      groupId,
      batchNumber,
      totalBatches,
      itemsInCurrentBatch,
      batchSize,
      totalItems: group.totalItems,
      completedItems: group.completedItems,
      isPaused: this.batchPauseTimer !== null,
      pauseRemaining: this.batchPauseEndTime > 0 ? Math.max(0, this.batchPauseEndTime - Date.now()) : 0,
      pauseDuration: 0,
    }
  }

  private getLastActiveBatchGroupId(): string | null {
    // Find a group that still has pending items
    for (const [groupId] of this.batchGroups) {
      const hasPending = this.items.some(i => i.batchGroupId === groupId && (i.status === 'pending' || i.status === 'downloading'))
      if (hasPending) return groupId
    }
    return null
  }

  private startBatchPause(groupId: string): void {
    const group = this.batchGroups.get(groupId)
    if (!group) return

    // Calculate pause duration based on total items
    const pauseMinutes = group.totalItems <= 50
      ? this.batchSettings.batchPauseShort
      : this.batchSettings.batchPauseLong

    // Minimum 5 minutes
    const pauseMs = Math.max(5 * 60 * 1000, pauseMinutes * 60 * 1000)
    this.batchPauseEndTime = Date.now() + pauseMs

    logger.info('Batch pause', `Starting ${pauseMinutes}min pause for batch group ${groupId} (${group.completedItems}/${group.totalItems} completed)`)

    // Update countdown info
    this.countdownInfo = {
      type: 'batch-pause',
      remaining: pauseMs,
      total: pauseMs,
      label: `Batch pause: resuming in ${Math.ceil(pauseMs / 60000)}:00`,
    }
    this.emitUpdate()

    // Start countdown interval (emits update every second)
    this.countdownInterval = setInterval(() => {
      const remaining = Math.max(0, this.batchPauseEndTime - Date.now())
      const mins = Math.floor(remaining / 60000)
      const secs = Math.floor((remaining % 60000) / 1000)
      this.countdownInfo = {
        type: 'batch-pause',
        remaining,
        total: pauseMs,
        label: `Batch pause: resuming in ${mins}:${String(secs).padStart(2, '0')}`,
      }
      this.emitUpdate()

      if (remaining <= 0) {
        this.clearBatchTimers()
        this.countdownInfo = null
        this.emitUpdate()
        // Resume processing
        if (!this.isPaused) {
          this.processNext()
        }
      }
    }, 1000)

    // Set the auto-resume timer
    this.batchPauseTimer = setTimeout(() => {
      this.clearBatchTimers()
      this.countdownInfo = null
      this.emitUpdate()
      if (!this.isPaused) {
        this.processNext()
      }
    }, pauseMs)
  }

  private startDownloadDelay(delayMs: number): void {
    this.countdownInfo = {
      type: 'download-delay',
      remaining: delayMs,
      total: delayMs,
      label: `Next download in ${Math.ceil(delayMs / 1000)}s`,
    }
    this.emitUpdate()

    const startTime = Date.now()
    this.countdownInterval = setInterval(() => {
      const elapsed = Date.now() - startTime
      const remaining = Math.max(0, delayMs - elapsed)
      this.countdownInfo = {
        type: 'download-delay',
        remaining,
        total: delayMs,
        label: `Next download in ${Math.ceil(remaining / 1000)}s`,
      }
      this.emitUpdate()

      if (remaining <= 0) {
        this.clearCountdownInterval()
        this.countdownInfo = null
        this.emitUpdate()
      }
    }, 1000)
  }

  private clearBatchTimers(): void {
    if (this.batchPauseTimer) {
      clearTimeout(this.batchPauseTimer)
      this.batchPauseTimer = null
    }
    this.batchPauseEndTime = 0
    this.clearCountdownInterval()
  }

  private clearCountdownInterval(): void {
    if (this.countdownInterval) {
      clearInterval(this.countdownInterval)
      this.countdownInterval = null
    }
  }

  private clearDelayTimer(): void {
    if (this.delayTimer) {
      clearTimeout(this.delayTimer)
      this.delayTimer = null
    }
  }

  addItem(item: Omit<QueueItem, 'id' | 'status' | 'addedAt'>): { id: string; position: number } {
    const id = `queue-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    const newItem: QueueItem = {
      ...item,
      id,
      status: 'pending',
      addedAt: Date.now(),
    }

    this.items.push(newItem)

    // Track batch group
    if (item.batchGroupId) {
      const existing = this.batchGroups.get(item.batchGroupId)
      if (existing) {
        existing.totalItems++
      } else {
        this.batchGroups.set(item.batchGroupId, {
          totalItems: 1,
          completedItems: 0,
          sourceType: item.sourceType || 'playlist',
        })
      }
    }

    this.emitUpdate()

    // Start processing if not already
    if (!this.isProcessing && !this.isPaused) {
      this.processNext()
    }

    return { id, position: this.items.length }
  }

  removeItem(id: string): boolean {
    const index = this.items.findIndex(i => i.id === id)
    if (index === -1) return false

    const item = this.items[index]

    // If this is the currently downloading item, cancel it
    if (item.status === 'downloading' && this.currentItemId === id) {
      this.downloader.cancel()
      this.currentItemId = null
      this.isProcessing = false
    }

    this.items.splice(index, 1)
    this.emitUpdate()

    // If we cancelled the current item, process next
    if (!this.isProcessing && !this.isPaused) {
      this.processNext()
    }

    return true
  }

  cancelItem(id: string): boolean {
    const item = this.items.find(i => i.id === id)
    if (!item) return false

    if (item.status === 'downloading' && this.currentItemId === id) {
      this.downloader.cancel()
      item.status = 'cancelled'
      this.currentItemId = null
      this.isProcessing = false
      this.emitUpdate()

      // Process next item
      if (!this.isPaused) {
        setTimeout(() => this.processNext(), 500)
      }
    } else if (item.status === 'pending') {
      item.status = 'cancelled'
      this.emitUpdate()
    }

    return true
  }

  async processNext(): Promise<void> {
    if (this.isProcessing || this.isPaused) return

    // Find next pending item (skip paused items)
    const nextItem = this.items.find(i => i.status === 'pending')
    if (!nextItem) return

    this.isProcessing = true
    this.currentItemId = nextItem.id
    nextItem.status = 'downloading'
    // Set initial progress so UI shows progress bar immediately
    nextItem.progress = {
      percent: 0,
      currentFile: nextItem.title,
      currentIndex: 1,
      totalFiles: 1,
      status: 'downloading',
    }
    logger.info('Starting download', `${nextItem.title} (${nextItem.id})`)
    this.emitUpdate()

    try {
      await this.downloader.download({
        url: nextItem.url,
        title: nextItem.title,
        format: nextItem.format,
        audioOnly: nextItem.audioOnly,
        outputPath: this.downloadPath,
        organizeByType: this.settings.organizeByType ?? true,
        delayBetweenDownloads: this.settings.delayBetweenDownloads ?? 3000,  // Default 3s to avoid 429
        subtitleOptions: nextItem.subtitleOptions,
      })
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error)
      logger.error('Queue download error', errorMsg)

      // CRITICAL: Reset queue state on error so queue doesn't get stuck
      const item = this.items.find(i => i.id === this.currentItemId)
      if (item && item.status === 'downloading') {
        item.status = 'failed'
        item.error = errorMsg
      }
      this.currentItemId = null
      this.isProcessing = false
      this.emitUpdate()

      // Process next item after failure
      setTimeout(() => {
        if (!this.isPaused) {
          this.processNext()
        }
      }, 1000)
    }
  }

  pause(): void {
    this.isPaused = true
    // Cancel any batch/countdown timers
    this.clearBatchTimers()
    this.clearDelayTimer()
    this.clearCountdownInterval()
    this.countdownInfo = null
    // If currently downloading, cancel the download (yt-dlp will leave .part file for resume)
    if (this.currentItemId) {
      const item = this.items.find(i => i.id === this.currentItemId)
      if (item && item.status === 'downloading') {
        logger.info('Pausing download', item.title)
        item.status = 'paused'
        this.downloader.cancel()  // Leaves .part file intact for resume
      }
      this.currentItemId = null
      this.isProcessing = false
    }
    this.emitUpdate()
  }

  resume(): void {
    this.isPaused = false
    // Find paused item and set back to pending
    const pausedItem = this.items.find(i => i.status === 'paused')
    if (pausedItem) {
      logger.info('Resuming download', pausedItem.title)
      pausedItem.status = 'pending'
      pausedItem.progress = undefined  // Clear old progress
    }
    this.emitUpdate()

    if (!this.isProcessing) {
      this.processNext()
    }
  }

  clear(): void {
    // Cancel batch/countdown timers
    this.clearBatchTimers()
    this.clearDelayTimer()
    this.clearCountdownInterval()
    this.countdownInfo = null
    // Cancel current download if any
    if (this.currentItemId) {
      this.downloader.cancel()
      this.currentItemId = null
      this.isProcessing = false
    }

    // Remove all items and batch groups
    this.items = []
    this.batchGroups.clear()
    this.emitUpdate()
  }

  pauseItem(id: string): boolean {
    const item = this.items.find(i => i.id === id)
    if (!item) return false

    if (item.status === 'downloading' && this.currentItemId === id) {
      // Currently downloading - cancel and pause
      this.downloader.cancel()
      item.status = 'paused'
      item.progress = undefined
      this.currentItemId = null
      this.isProcessing = false
      this.emitUpdate()

      // Auto-start next pending item
      setTimeout(() => {
        if (!this.isPaused) {
          this.processNext()
        }
      }, 500)
    } else if (item.status === 'pending') {
      // Queued but not started - just mark as paused
      item.status = 'paused'
      this.emitUpdate()
    } else {
      return false
    }

    logger.info('Paused item', item.title)
    return true
  }

  resumeItem(id: string): boolean {
    const item = this.items.find(i => i.id === id)
    if (!item || item.status !== 'paused') return false

    // Set back to pending so it gets picked up
    item.status = 'pending'
    item.progress = undefined
    item.error = undefined
    this.emitUpdate()

    logger.info('Resumed item', item.title)

    // Start processing if not already
    if (!this.isProcessing && !this.isPaused) {
      this.processNext()
    }

    return true
  }

  retryItem(id: string): boolean {
    const item = this.items.find(i => i.id === id)
    if (!item) return false

    // Only retry failed or cancelled items
    if (item.status !== 'failed' && item.status !== 'cancelled') {
      return false
    }

    logger.info('Retrying download', item.title)

    // Reset item status
    item.status = 'pending'
    item.error = undefined
    item.progress = undefined

    this.emitUpdate()

    // Start processing if not already
    if (!this.isProcessing && !this.isPaused) {
      this.processNext()
    }

    return true
  }

  retryAllFailed(): number {
    let retriedCount = 0
    const failedItems = this.items.filter(i => i.status === 'failed')

    for (const item of failedItems) {
      item.status = 'pending'
      item.error = undefined
      item.progress = undefined
      retriedCount++
    }

    if (retriedCount > 0) {
      logger.info('Retrying all failed downloads', `${retriedCount} items`)
      this.emitUpdate()

      if (!this.isProcessing && !this.isPaused) {
        this.processNext()
      }
    }

    return retriedCount
  }

  getDownloader(): Downloader {
    return this.downloader
  }
}
